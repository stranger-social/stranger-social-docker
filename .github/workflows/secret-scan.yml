name: secret-scan

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  workflow_dispatch: {}

jobs:
  basic-guards:
    name: Basic repo guards
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Fail if .env exists in repo
        run: |
          if [ -f .env ]; then
            echo ".env file must not be committed." >&2
            exit 1
          fi
      - name: Fail if obvious secrets are present
        run: |
          set -e
          PATTERN="(SECRET_KEY_BASE|OTP_SECRET|VAPID_PRIVATE_KEY|ACTIVE_RECORD_ENCRYPTION_(PRIMARY|DETERMINISTIC|KEY_DERIVATION)_KEY|AWS_SECRET_ACCESS_KEY|SMTP_PASSWORD)"
          if git ls-files | xargs -I{} sh -c "grep -E -n '${PATTERN}' '{}' || true" | grep -v ".env.example\|docs/\|README\|MIGRATION\|PRE_MIGRATION\|Home.md\|MCP.md\|docker-compose.yml" | grep -E ":.+${PATTERN}"; then
            echo "Potential secret detected in tracked files. Review and remove before pushing." >&2
            exit 1
          fi
      - name: Fail if certbot certs are committed
        run: |
          set -e
          if git ls-files | grep -E '^certbot/conf/(live|archive|keys|csr|accounts|renewal)/' | grep -q .; then
            echo "Certbot-generated files must not be committed (certs/renewal/config). Remove them and rely on .gitkeep placeholders." >&2
            exit 1
          fi
  gitleaks:
    name: Gitleaks scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Gitleaks (full history)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Scan full git history to catch any accidentally committed secrets
          args: detect -v --redact
